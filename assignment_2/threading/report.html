<h1 id="assignment-2-threads">Assignment 2 (Threads)</h1>

<h2 id="program-layout">Program layout</h2>

<p>The solutions, attractors, convergences and most constants are declared as global variables. Structs are used to pass the results from Newton's Method and to pass job data to compute threads.</p>

<h3 id="main">Main</h3>
<ol>
  <li>Parameters are set from arguments (using getopt)
    <ol>
      <li>-t (THREAD COUNT, DEFAULT: 1)</li>
      <li>-l (LINE COUNT, DEFAULT: 2000)</li>
      <li>-j (PIXELS PER JOB, DEFAULT: LINE COUNT)</li>
      <li>-s (SLEEP TIME IN NANOSECONDS, DEFAULT: 1000000)</li>
      <li>(last) (DEGREE, DEFAULT: 3)</li>
    </ol>
  </li>
  <li>Since the work is going to be divided into chunks of [PIXELS PER JOB] size, additional parameters related to this are set</li>
  <li>The roots to the equation are found</li>
  <li>Memory is allocated</li>
  <li>Threads are created</li>
  <li>Threads are joined</li>
  <li>Memory is freed</li>
</ol>

<h3 id="compute-threads">Compute threads</h3>
<ol>
  <li>Based on the job size, we will have some number of jobs. These jobs are referred to by an index.</li>
  <li>Each compute thread will try to access a mutex to read this index (and increment it for the next accessor).</li>
  <li>This index corresponds to a segment of the arrays at which work will be performed.</li>
  <li>Once that piece of work is performed, we mark that index to be "done".</li>
  <li>As long as there is work, the threads will be keep going.</li>
</ol>

<h3 id="write-thread">Write thread</h3>
<ol>
  <li>The files are created.</li>
  <li>Headers are written to the files.</li>
  <li>Colors are generated for later.</li>
  <li>We loop through every finished job - writing the colors corresponding to data from those jobs to the file. If we encounter a job that hasn't been done yet, we sleep for a while.</li>
  <li>This is repeated until there are no more jobs.</li>
</ol>

<h2 id="performance-aspects">Performance aspects</h2>

